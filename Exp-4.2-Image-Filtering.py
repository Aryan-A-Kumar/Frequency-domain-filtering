# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U0bH7PJO0Le8q9tSuFKBye-svawkAZwU
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, fixed, Dropdown, IntSlider, FloatSlider, FileUpload
import io

def ideal_filter(shape, cutoff, filter_type='lpf'):
    rows, cols = shape
    crow, ccol = rows // 2 , cols // 2
    mask = np.zeros((rows, cols), np.uint8)

    if filter_type == 'lpf':
        mask[crow - cutoff:crow + cutoff, ccol - cutoff:ccol + cutoff] = 1
    elif filter_type == 'hpf':
        mask[:, :] = 1
        mask[crow - cutoff:crow + cutoff, ccol - cutoff:ccol + cutoff] = 0
    return mask

def gaussian_filter(shape, cutoff, filter_type='lpf'):
    rows, cols = shape
    crow, ccol = rows // 2 , cols // 2
    x = np.linspace(-ccol, ccol, cols)
    y = np.linspace(-crow, crow, rows)
    x, y = np.meshgrid(x, y)
    d = np.sqrt(x**2 + y**2)

    if filter_type == 'lpf':
        mask = np.exp(-(d**2 / (2 * (cutoff**2))))
    elif filter_type == 'hpf':
        mask = 1 - np.exp(-(d**2 / (2 * (cutoff**2))))
    return mask

def butterworth_filter(shape, cutoff, order=2, filter_type='lpf'):
    rows, cols = shape
    crow, ccol = rows // 2 , cols // 2
    x = np.linspace(-ccol, ccol, cols)
    y = np.linspace(-crow, crow, rows)
    x, y = np.meshgrid(x, y)
    d = np.sqrt(x**2 + y**2)

    if filter_type == 'lpf':
        mask = 1 / (1 + (d / cutoff)**(2 * order))
    elif filter_type == 'hpf':
        mask = 1 / (1 + (cutoff / d)**(2 * order))
    return mask

def apply_filter(image, filter_func, cutoff, filter_type='lpf', order=2):
    f = np.fft.fft2(image)
    fshift = np.fft.fftshift(f)
    magnitude_spectrum = 20 * np.log(np.abs(fshift))

    filter_mask = filter_func(image.shape, cutoff, filter_type=filter_type)

    filtered_fshift = fshift * filter_mask
    filtered_magnitude_spectrum = 20 * np.log(np.abs(filtered_fshift))

    f_ishift = np.fft.ifftshift(filtered_fshift)
    img_back = np.fft.ifft2(f_ishift)
    img_back = np.abs(img_back)

    return magnitude_spectrum, filter_mask, filtered_magnitude_spectrum, img_back

def display_results(image, magnitude_spectrum, filter_mask, filtered_magnitude_spectrum, filtered_image):
    plt.figure(figsize=(12, 12))

    plt.subplot(3, 2, 1)
    plt.imshow(image, cmap='gray')
    plt.title('Input Image')
    plt.axis('off')

    plt.subplot(3, 2, 2)
    plt.imshow(magnitude_spectrum, cmap='gray')
    plt.title('Magnitude Spectrum')
    plt.axis('off')

    plt.subplot(3, 2, 3)
    plt.imshow(filter_mask, cmap='gray')
    plt.title('Filter')
    plt.axis('off')

    plt.subplot(3, 2, 4)
    plt.imshow(filtered_image, cmap='gray')
    plt.title('Filtered Image')
    plt.axis('off')

    plt.subplot(3, 2, 5)
    plt.imshow(filtered_magnitude_spectrum, cmap='gray')
    plt.title('Filtered Magnitude Spectrum')
    plt.axis('off')

    plt.show()

def frequency_filtering_pipeline(image_data, filter_type, cutoff, order=2):
    image = cv2.imdecode(np.frombuffer(image_data['content'], np.uint8), cv2.IMREAD_GRAYSCALE)

    filter_func = None
    if filter_type == 'ideal_lpf':
        filter_func = ideal_filter
        filter_category = 'lpf'
    elif filter_type == 'ideal_hpf':
        filter_func = ideal_filter
        filter_category = 'hpf'
    elif filter_type == 'gaussian_lpf':
        filter_func = gaussian_filter
        filter_category = 'lpf'
    elif filter_type == 'gaussian_hpf':
        filter_func = gaussian_filter
        filter_category = 'hpf'
    elif filter_type == 'butterworth_lpf':
        filter_func = butterworth_filter
        filter_category = 'lpf'
    elif filter_type == 'butterworth_hpf':
        filter_func = butterworth_filter
        filter_category = 'hpf'
    else:
        raise ValueError("Invalid filter type")

    magnitude_spectrum, filter_mask, filtered_magnitude_spectrum, filtered_image = apply_filter(
        image, filter_func, cutoff, filter_type=filter_category, order=order)

    display_results(image, magnitude_spectrum, filter_mask, filtered_magnitude_spectrum, filtered_image)

# Define the interactive sliders and dropdowns
def interactive_filtering(file, filter_type, cutoff, order):
    if file:
        file_data = list(file.values())[0]
        frequency_filtering_pipeline(file_data, filter_type, cutoff, order)

# Widget for file upload
file_upload = FileUpload(accept='.png,.jpg,.jpeg', multiple=False)

# Dropdown for filter type selection
filter_type_dropdown = Dropdown(
    options=['ideal_lpf', 'ideal_hpf', 'gaussian_lpf', 'gaussian_hpf', 'butterworth_lpf', 'butterworth_hpf'],
    value='gaussian_lpf',
    description='Filter Type:',
)

# Slider for cutoff frequency
cutoff_slider = IntSlider(
    value=30,
    min=1,
    max=100,
    step=1,
    description='Cutoff Freq:',
)

# Slider for Butterworth filter order
order_slider = IntSlider(
    value=2,
    min=1,
    max=10,
    step=1,
    description='Butterworth Order:',
)

# Combine all widgets into an interactive interface
interact(interactive_filtering, file=file_upload, filter_type=filter_type_dropdown, cutoff=cutoff_slider, order=order_slider);

# Question 2
# Reusing functions from Question 1
leopard_elephant = cv2.imread('leopard_elephant.jpg')
plt.imshow(leopard_elephant, cmap='gray')
def create_hybrid_image(img1, img2, cutoff_low, cutoff_high, order = 2):
    # Apply LPF to the first image (Marilyn)
    low_freq_img = apply_filter(img1, butterworth_filter, cutoff_low, 'lpf', order=2)[3]

    # Apply HPF to the second image (Einstein)
    high_freq_img = apply_filter(img2, butterworth_filter, cutoff_high, 'hpf', order=2)[3]

    # Combine the low-frequency and high-frequency images
    hybrid_image = low_freq_img + high_freq_img

    # Normalize the hybrid image to the 0-255 range
    hybrid_image = np.clip(hybrid_image, 0, 255)

    return hybrid_image

# Load images
einstein_image_name = input("Enter the filename for the first image (Einstein): ")
marilyn_image_name = input("Enter the filename for the second image (Marilyn): ")

# Read the images in grayscale
einstein = cv2.imread(einstein_image_name, cv2.IMREAD_GRAYSCALE)
marilyn = cv2.imread(marilyn_image_name, cv2.IMREAD_GRAYSCALE)

# Check if images are loaded successfully
if einstein is None or marilyn is None:
    print("Error loading images. Please check the file paths.")
else:
    print("Images loaded successfully.")

# Create hybrid image
hybrid_image = create_hybrid_image(marilyn, einstein, cutoff_low=20, cutoff_high=20)

# Display the hybrid image
plt.figure(figsize=(8, 8))
plt.imshow(hybrid_image, cmap='gray')
plt.title('Hybrid Image (Einstein + Marilyn)')
plt.axis('off')
plt.show()

# Save the hybrid image
cv2.imwrite('hybrid_image.png', hybrid_image)

import cv2
import numpy as np
import matplotlib.pyplot as plt

def remove_noise(img, output_prefix):
    # Compute the 2D Fourier Transform and shift the zero frequency components to the center
    img_fft = np.fft.fftshift(np.fft.fft2(img))

    # Get image dimensions
    img_h, img_w = img.shape
    img_ch = img_h // 2
    img_cw = img_w // 2

    # Define parameters for noise removal
    r = 2  # Radius for noise removal
    n = 2  # Width of noise removal strip

    # Create a copy of the FFT image for processing
    img_fft_cleaned = img_fft.copy()

    # Remove noise by setting a strip in the frequency domain to 1
    img_fft_cleaned[img_ch - r:img_ch + r, 0:img_ch - n] = 1
    img_fft_cleaned[img_ch - r:img_ch + r, img_ch + n:] = 1

    # Compute the magnitude spectrum and log-transform it
    magnitude_spectrum_original = np.log(1 + np.abs(img_fft))
    magnitude_spectrum_cleaned = np.log(1 + np.abs(img_fft_cleaned))

    # Restore the image by applying the inverse Fourier Transform
    img_restored = np.fft.ifft2(np.fft.ifftshift(img_fft_cleaned))
    img_restored_real = np.abs(img_restored)

    # Save the original noisy image
    cv2.imwrite(f'{output_prefix}_noisy.png', img)

    # Save the magnitude spectrum of the original and cleaned images
    plt.imsave(f'{output_prefix}_magnitude_spectrum_original.png', np.clip(magnitude_spectrum_original, 0, 255).astype(np.uint8), cmap='gray')
    plt.imsave(f'{output_prefix}_magnitude_spectrum_cleaned.png', np.clip(magnitude_spectrum_cleaned, 0, 255).astype(np.uint8), cmap='gray')

    # Save the restored image
    cv2.imwrite(f'{output_prefix}_restored.png', img_restored_real)

    # Display the results
    plt.figure(figsize=(20, 20))
    plt.subplot(1, 4, 1)
    plt.imshow(img, cmap='gray')
    plt.title('Noisy Image')

    plt.subplot(1, 4, 2)
    plt.imshow(magnitude_spectrum_original, cmap='gray')
    plt.title('Magnitude Spectrum (Original)')

    plt.subplot(1, 4, 3)
    plt.imshow(magnitude_spectrum_cleaned, cmap='gray')
    plt.title('Magnitude Spectrum (Cleaned)')

    plt.subplot(1, 4, 4)
    plt.imshow(img_restored_real, cmap='gray')
    plt.title('Restored Image')

    plt.show()

# List of noisy image files to process
noisy_image_file_name = input("Enter the noisy input file (e.g., cameraman_noisy1.jpg or cameraman_noisy2.jpg): ")
# Load and process the noisy image
img = cv2.imread(noisy_image_file_name, cv2.IMREAD_GRAYSCALE)

if img is not None:
    output_prefix = noisy_image_file_name.split('.')[0]
    print(f"Processing {noisy_image_file_name}...")
    remove_noise(img, output_prefix)
    print(f"Images saved with prefix '{output_prefix}'")
else:
    print("Error: Image could not be loaded. Please check the file path.")

